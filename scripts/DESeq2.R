
# Load necessary packages
#if (!requireNamespace("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install("DESeq2")
library(DESeq2);packageVersion("DESeq2") 
library(DEGreport);packageVersion("DEGreport") 
library(vsn);packageVersion("vsn") 
library(ggplot2);packageVersion("ggplot2") 
library(RColorBrewer);packageVersion("RColorBrewer") 
library(ggpubr);packageVersion("ggpubr") 
library(tidyverse);packageVersion("tidyverse") 
library(pheatmap);packageVersion("pheatmap") 
library(EnhancedVolcano);packageVersion("EnhancedVolcano") 
library(ggrepel)

### 1.  Define features and conditions for comparison
#FeatureList = c("CDS", "exon", "five_prime_UTR", "three_prime_UTR", "mRNA", "gene", "ncRNA_gene" ) #"lnc_RNA"
FeatureList = c("gene")

Condition = "condition"
nominator = "drought"
denominator = "control"

dataPath = "../data/"
OutPath_base = "../results/"

if (!dir.exists(OutPath_base)) dir.create(OutPath_base)

# Loop over each feature type
for (Feature in FeatureList) {
  #Feature = "lnc_RNA"
  print(paste("Processing feature type:", Feature))
  
  OutPath = paste0(OutPath_base, Feature, sep = "/")
  OutPath_plots = paste0(OutPath, "plots/")
  OutPath_tables = paste0(OutPath, "tables/")
  OutPath_rObj = paste0(OutPath, "R_objects/")
  
  if (!dir.exists(OutPath)) dir.create(OutPath)
  if (!dir.exists(OutPath_plots)) dir.create(OutPath_plots)
  if (!dir.exists(OutPath_tables)) dir.create(OutPath_tables)
  if (!dir.exists(OutPath_rObj)) dir.create(OutPath_rObj)
  
  ### 2. Data preparation
  ## Data preparation  #exp of input count table name: processed_CDS_countsTable.tsv
  countTable = paste0(dataPath, "processed_", Feature, "_countsTable.tsv", sep = "")
  countData = read.table(countTable, check.name=FALSE, header=TRUE, row.names=1, sep="\t")
  colTable = "../data/colData.txt"
  colData = read.table(colTable, header=TRUE, row.names="sample", sep="\t")
  colData$condition = as.factor(colData$condition)
  
  ncol(countData) == nrow(colData) 
  all(rownames(colData) == colnames(countData))
  
  stopifnot(ncol(countData) == nrow(colData))
  stopifnot(all(rownames(colData) == colnames(countData)))
  
  ### 3. DESeq2: design = condition
  ### Pre-filtering DESeqDataSet (dds) object: keep only rows that have a count of at least 1 for minimal number of samples per group
  # Design the formula
  Design = as.formula(paste0("~ ", Condition, collapse = ""))    
  
  # Make a dds object
  dds = DESeqDataSetFromMatrix(countData = countData, colData = colData, design = Design)
  
  # Count number of samples in each condition of comparison and find the minimum number of samples per group
  smallestGroupSize = min(table(colData[[Condition]])[c(nominator, denominator)])
  
  # Pre-filtering dds object: keep only rows that have a count of at least 1 for minimal number of samples
  keep = rowSums(counts(dds) >= 1) >= smallestGroupSize
  dds = dds[keep,]
  
  # Factor levels
  dds[[Condition]] = factor(dds[[Condition]])
  
  # Specifying the reference level
  dds[[Condition]] = relevel(dds[[Condition]], ref = denominator)
  
  # Differential expression analysis using DESeq function, fitType has been set to "local"
  ddsW = DESeq(dds, fitType="local")
  file_ddsW = paste0(OutPath_rObj, "ddsW_local.rds", sep = "" )
  saveRDS(ddsW, file = file_ddsW)
  # ddsW = readRDS(file = file_ddsW)
  
  meta = colData(ddsW)
  
  #### Dispersion estimates
  # Each black dot represents the dispersion for one gene.
  # Red line is fitted to the data (black dots).
  # Then the dispersions are adjusted towards the red line, resulting in the final (blue) dispersion estimates.
  # Typically, dispersions are highest at low counts and level off at higher counts.
  
  # Plot dispersion estimates: per-gene dispersion estimates with the fitted mean-dispersion relationship
  png(paste0(OutPath_plots,"1_qc_dispersion_est_per_gene.png", sep = ""), width=10,height=8,units="in",res=300)
  print(plotDispEsts(ddsW, main = "Plot dispersion estimates generated by local fitType"))
  dev.off()
  
  ### 4. Normalizaton for downstream analysis and visualization
  #### Variance Stabilizing Transformation
  # Variance stablizing transformation for visualization
  vsd_blind = vst(ddsW, blind=TRUE)
  print(nrow(ddsW))
  
  file_vsd_blind = paste0(OutPath_rObj, "vst_blindddsW.rds", sep = "" )
  saveRDS(vsd_blind, file = file_vsd_blind)
  # vsd_blind = readRDS(file = file_vsd_blind)
  
  # Variance stablizing transformation for downstream analysis
  vsd = vst(ddsW, blind=FALSE)
  file_vsd = paste0(OutPath_rObj, "vstddsW.rds", sep = "" )
  saveRDS(vsd, file = file_vsd)
  # vsd = readRDS(file = file_vsd)
  
  mat = assay(vsd)
  mat_out = paste0(OutPath_tables, "vst_counts.tsv", sep = "")
  write.table(data.frame("featureID"=rownames(mat),mat, check.names = FALSE),file=mat_out, quote = FALSE,row.names=FALSE,sep = "\t")
  
  #### Normalized count
  normalized_counts = counts(ddsW, normalized=TRUE)
  normalized_counts_file = paste0(OutPath_tables, "normalized_counts_byDESeq2_tsv", sep = "")
  write.table(normalized_counts, file = normalized_counts_file, sep="\t", quote=F, col.names=NA)
  
  ### 5. QC
  #### QC: meanSdPlot
  # Effects of transformations on the variance:
  # meanSdPlot plots the standard deviation of the transformed data using the variance stabilizing transformation, across samples, against the mean.</div>
  # Plot row standard deviations versus row means: Sample similarity within groups
  png(paste0(OutPath_plots,"2_qc_meanSdPlot_vst.png", sep = ""), width=10,height=8,units="in",res=300)
  msd = meanSdPlot(assay(vsd_blind), plot = FALSE)
  print(msd$gg + ggtitle("Standard deviation of the transformed (vst) data")) 
  dev.off()
  
  #### QC: PCA plot
  #Shows the samples in the 2D plane spanned by their first two principal components. It is useful for visualizing the overall effect of experimental covariates.
  png(paste0(OutPath_plots, "3_qc_pca_vst.png", sep = ""), width=8,height=6,units="in",res=600)
  
  data = plotPCA(vsd_blind, intgroup=c(Condition) ,ntop= 1000, returnData=TRUE)
  out = paste0(OutPath_tables, "3_qc-pcavst.tsv", sep = "")
  write.table(data.frame(data),file=out, quote = FALSE,row.names=TRUE,sep = "\t")
  
  percentVar = round(100 * attr(data, "percentVar"))
  pca_plot = ggplot(data, aes(PC1, PC2, color=data[[Condition]])) + geom_point(size=2) + 
    geom_text_repel(aes(label=row.names(data)), size = 3) +  scale_colour_manual(values = c("red3", "seagreen4")) +
    xlab(paste0("PC1: ",percentVar[1],"% variance")) + ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
    ggtitle("Principal component plot for 1000 most variable features") + labs(color = Condition) 
  print(pca_plot)
  dev.off()
  
  #### Compute pairwise correlation values
  vsd_cor <- cor(mat) 
  head(vsd_cor)   ## check the output of cor()
  
  ### Plot heatmap  pairwise correlation
  ann_col = as.data.frame(meta[, c(Condition, "rep")])
  
  # Create the ann_color list using rep information
  ann_color = list(rep = c("rep1" = "darkslategray2","rep2" = "yellow2", "rep3" = "thistle1" ), condition = c("control" = "mediumseagreen", "drought" = "hotpink")) #  , "seagreen2", "hotpinkdarkseagreen1"
  
  file_QC_heatmap =paste0(OutPath_plots, "4_qc_pairwise_correlation_heatmap.png")
  
  # Color palettes: RGn, PiYG, BrBG, Spectral, RdBu, PuOr, RdYlBu, BrBG, Paired
  heat_colors <- brewer.pal(9, "Blues")
  title_cor = "Heatmap: pairwise correlation values"
  
  pheatmap::pheatmap(vsd_cor, color = heat_colors, cluster_cols = T, cluster_rows = T, show_colnames = T, show_rownames = T, annotation_colors = ann_color, annotation_col =  ann_col, clustering_method = "ward.D", clustering_distance_rows = "euclidean", clustering_distance_cols =  "euclidean", fontsize_col = 4, angle_col = 90, cellheight = 20, cellwidth = 20, cutree_cols = 2, annotation_legend = T,legend = T, fontsize = 5, main = title_cor, cutree_rows = 2, file = file_QC_heatmap)
  
  ### 6. Results: |Shrunken Log2 FC| ≥ 1 and Adjusted P-value ≤ 0.1, Top features: 50
  padj = 0.1
  lfc = 1
  topGene = 50
  gene = Feature
  
  res = results(ddsW, contrast=c(Condition,nominator, denominator))
  res_shrink = lfcShrink(ddsW, contrast=c(Condition,nominator, denominator), res=res, type = c("ashr"))
  res_shrink_O = res_shrink[order(res_shrink$padj),]
  res_shrink_O_tbl = res_shrink_O %>%
    data.frame() %>%
    rownames_to_column(var="featureID") 
  
  all_res_out = paste0(OutPath_tables, "results_",nominator,"_vs_", denominator, "_all.tsv", sep = "")
  write.table(res_shrink_O_tbl, file = all_res_out, quote = FALSE, row.names = FALSE, sep = "\t")
  
  # In DESeq2, the function plotMA shows the log2 fold changes attributable to a given variable over the mean of normalized counts for all the samples in the DESeqDataSet. Points are colored red if the adjusted P-value is less than 0.1. Points which fall out of the window (-5, 5) are plotted as open triangles pointing either up or down.
  png(paste0(OutPath_plots,"5_plotMA_results_",nominator,"_vs_",denominator,"_padj_", padj, "_", gene,".png", sep = ""), width=12,height=10,units="in",res=400)
  main = paste0("Deseq2 results MA-plot: ", nominator, " vs ", denominator ,sep = " ")
  maPlot = plotMA(res_shrink_O, alpha = 0.1, main = main, cex = 0.7, ylim = c(-5,5), colLine = "black", colSig = "firebrick2") + abline(h = c(-2,2), lwd = 2, col = "forestgreen") # dev.off()
  dev.off()
  
  png(paste0(OutPath_plots,"5_2_plotMA_results_",nominator,"_vs_",denominator,"_padj_", padj, "_", gene,".png", sep = ""), width=12,height=10,units="in",res=400)
  res_shrink_O$gene = rownames(res_shrink_O)
  maplot2 = ggmaplot(res_shrink_O, fdr = 0.1, fc = 2, size = 1,palette = c("#B31B21", "#1465AC", "darkgray"),genenames = as.vector(res_shrink_O$gene),legend="top", top = 0,font.label = c("bold", 10),label.rectangle = TRUE, font.legend = c("bold",12),font.main = "bold")
  print(maplot2)
  dev.off()
  
  
  # Filter the shrunken results
  res_shrink_F = res_shrink_O[!is.na(res_shrink_O$padj) & res_shrink_O$padj<=padj & abs(res_shrink_O$log2FoldChange)>=lfc,]
  
  # Volcano plot using shrunken results
  # A type of scatterplot that shows statistical significance (adjusted P-value < 0.1) versus |Log2 FC| > 2. It enables quick visual identification of genes with large fold changes that are also statistically significant. These may be the most biologically significant genes. In a volcano plot, the most upregulated genes are towards the right, the most downregulated genes are towards the left, and the most statistically significant genes are towards the top.
  png(paste0(OutPath_plots,"6_plotVolcano_results_", nominator, "_vs_", denominator, "_", gene, ".png", sep = ""),  width=18,height=15,units="in",res=400)
  print(EnhancedVolcano(res_shrink_O,
                        lab = rownames(res_shrink_O),
                        x = 'log2FoldChange', y = 'pvalue', 
                        subtitle = paste(nominator, "vs", denominator ,sep = " "),
                        FCcutoff = 2, pCutoffCol = "padj", pCutoff = 1e-1,
                        cutoffLineType = 'twodash', cutoffLineWidth = 0.5, 
                        pointSize = 0.5, labSize = 2.5, selectLab = res_shrink_O_tbl$featureID[1:20],
                        colAlpha = 0.8, axisLabSize = 11, boxedLabels = TRUE, drawConnectors = TRUE,
                        legendLabels=c('Not sig.','Log2 FC','adjusted P-value', 'adjusted P-value & Log2 FC'),
                        legendPosition = 'right', legendLabSize = 11, legendIconSize = 3.0)) 
  dev.off()
  
  # Convert the results object into a tibble
  res_shrink_F_tbl = res_shrink_F %>%
    data.frame() %>%
    rownames_to_column(var="featureID") %>%
    as_tibble()
  
  res_out = paste0(OutPath_tables, "results_",nominator,"_vs_", denominator, "_lfc_",lfc,"_padj_",padj,".tsv", sep = "")
  write.table(res_shrink_F_tbl, file = res_out, quote = FALSE, row.names = FALSE, sep = "\t")
  nGene = rownames(res_shrink_F)[which(res_shrink_F$padj<padj)]
  
  if (length(nGene) < topGene) {
    topGene = length(nGene)
  }
  
  padjs = res_shrink_F_tbl$padj
  lfcs = res_shrink_F_tbl$log2FoldChange
  
  # Plot of normalized counts for top genes: using DESeqDataSet, normalized by size factor and using outlier-replaced counts, Normalized counts plus a pseudocount of 0.5 are shown by default.
  plts = list()
  for(n in 1:topGene) {
    data_countPlot = plotCounts(ddsW, gene=nGene[n], intgroup=c(Condition), returnData=T, normalized = T, pc = 1, replaced = T, transform=T)
    sample_ID = rownames(data_countPlot)
    plts[[n]] =  ggplot(data_countPlot, aes(x = .data[[Condition]], y = count, color = .data[[Condition]])) +
      geom_point(position=position_jitter(w = 0.3, h = 0)) + 
      geom_text_repel(aes(label = sample_ID), 
                      box.padding = 0.001, point.padding = 0.001, size = 4, min.segment.length = 0.01) +  
      theme_bw() +
      ggtitle(paste(nGene[n],"\nLFC: ", lfcs[n], "\nFDR: ", padjs[n], sep = "")) +
      theme(plot.title = element_text(hjust = 0.5)) +
      labs(x = Condition, color = Condition) +
      scale_color_manual(values =  c("red3", "seagreen4"))
  }
  
  topCnt_pdf = paste0(OutPath_plots, "7_plotCounts_top_", topGene, "_", nominator,"_vs_", denominator, ".pdf", sep = "")
  ggexport(plotlist = plts, filename = topCnt_pdf)
  
  pref = paste0(nominator,"_vs_", denominator, sep = "")
  prefTitle = paste0("Condition: ", nominator, " vs ", denominator, sep = " ")
  
  # print(prefTitle)
  ddsW_DEG = ddsW
  
  # Plot top genes using DESeqDataSet, log2 transformedćcounts.
  # Plots top differentially expressed genes, colored by different conditions and batches shown with different shapes. 
  # It helps in identifying genes that are significantly altered across conditions and batches. Y shows the log2 transformed abundance of counts.</div>')
  outFile = paste0(OutPath_plots,"8_DEGreport_degPlot_top_", topGene, "_", pref,".png", sep = "")
  png(outFile, width=16,height=10,units="in",res=500)
  degPLOT = DEGreport::degPlot(dds = ddsW_DEG, res = res_shrink_F, n = topGene, xs = Condition, group = Condition, sizePoint = 0.8)
  degPLOT2 = degPLOT + ggplot2::theme(text=element_text(size=7)) + ggplot2::scale_color_manual(values = c("indianred1", "mediumseagreen")) 
  print(degPLOT2)
  #print(DEGreport::degPlot(dds = ddsW_DEG, res = res_shrink_F, n = topGene, xs = Condition, group = Condition, sizePoint = 0.8)) # dds object is output from DESeq2 
  dev.off()
  
  # Order results by padj values
  top_sig_genes = res_shrink_F_tbl %>%
    dplyr::arrange(padj) %>%
    dplyr::pull(featureID) %>%
    head(n=topGene)
  
  # Normalized counts for nGene significant genes
  top_sig_norm = as.data.frame(normalized_counts) %>%
    rownames_to_column(var = "featureID") %>%
    dplyr::filter(featureID %in% top_sig_genes)
  
  # Gathering the columns to have normalized counts to a single column
  gathered_top_sig = top_sig_norm %>%
    gather(colnames(top_sig_norm)[-1], key = "samplename", value = "normalized_counts")
  
  # Metadata of samples 
  metaCol = as.data.frame(meta) %>% 
    rownames_to_column(var="samplename")
  
  # Join normalized count and metadat
  gathered_top_sig_long = inner_join(metaCol, gathered_top_sig, by = "samplename")
  
  # plot normalized count from DESeqDataSet object
  # Normalized Count Plot:
  # This plot visualizes normalized counts ( without log transformation) computed by DESeq2 for top genes. 
  # Genes are colored based on different conditions, providing insights into differential expression across experimental conditions.
  outFile = paste0(OutPath_plots, "9_top_", topGene, "Genes_normaCount_",pref,".png", sep = "")
  png(outFile, width=16,height=10,units="in",res=400)
  top_features_plot = ggplot(gathered_top_sig_long) +
    geom_point(aes(x = featureID, y = normalized_counts, color = gathered_top_sig_long[[Condition]]), size = 1.5) +
    scale_y_log10() +
    xlab("transcript ID") +
    ylab("Normalized Counts") +
    ggtitle(paste0(prefTitle,"\nTop ", topGene," significant DE transcripts", sep = " ")) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, size =5)) + 
    scale_colour_manual(values = c("indianred1", "mediumseagreen")) +  
    theme(plot.title = element_text(hjust = 0.5)) + labs(color = Condition)
  print(top_features_plot)  
  dev.off()
  
  print(paste0("Number of significantly differentially expressed ", Feature, "s: "))
  print(paste0(" based on |Log2 FC| ≥ ", lfc , " and adjusted P-value ≤ ", padj, " is ", nrow(res_shrink_F_tbl), "."))
  
  sig_genes_h = res_shrink_F_tbl[1:50,c(1,2,3,6)]
  sig_genes_h$padj = as.numeric(sig_genes_h$padj)
  sig_genes_h$padj = format(sig_genes_h$padj, scientific = TRUE)
  
  head(sig_genes_h)
  
  # #### 7. QC: Variance plots
  # # Mean-Variance QC plot:
  # # P-value distribution gives an idea on how well the model is capturing the input data. In general, we expect to have a flat distribution with peaks at 0 and 1. The mean count ( **without log transformation**) information are added to check if any set of genes are enriched in any specific P-value range.
  # # Variation (dispersion) and average expression relationship shouldn’t be a factor among the DEGs When plotting average mean and standard deviation, significant genes should be randomly distributed.
  # png(paste0(OutPath_plots, "8_qc_mean-variance_plots.png", sep = ""), width=9,height=6, units="in", res=400)
  # degQC(normalized_counts, meta[[Condition]], pvalue = res[["pvalue"]]) 
  # dev.off()
  # 
  # # Covariates effect on count data:
  # # If there are  covariates in a analysis, it is good to calculate the correlation between different variables that may affecting the gene expression. In this plot, clearly library size correlates with PC1.</div>
  # # Covariates effect on count data
  # png(paste0(OutPath_plots, "9_qc_covariantes_effect_on_counts.png", sep = ""), width=11,height=5, units="in", res=400)
  # resCov = degCovariates(log2(counts(ddsW)+0.5), colData(ddsW)[,c(Condition, "rep", "sizeFactor")]) 
  # dev.off()
  # 
  # # Covariates correlation with metrics:
  # # The correlation among covariates and metrics from the analysis can be tested. This is useful when the study has multiple variables. *degCorCov* function returns a correlation table, and plot the correlation heatmap for all the covariates and metrics in a table.</div>
  # # Covariates correlation with metrics
  # png(paste0(OutPath_plots, "10_qc_covariantes_correlation_with_matrices.png", sep = ""), width=5, height=4, units="in", res=400)
  # cor = degCorCov(colData(ddsW)[,c(Condition, "rep", "sizeFactor")]) 
  # dev.off()
  
  ### 8. Heatmap
  # To explore the VST normalized count matrix, _preprocessed to eliminate Hb/rRNA transcripts and batch effects_, we created two heatmaps. The first heatmap visualizes all significant genes, while the second one emphasizes the top 50 significant genes (based on adjusted P-value).</div>
  # Plotting a heatmap using batch-removed VST-normalized counts
  ann_col = as.data.frame(meta[, c(Condition, "rep")])
  
  # Create the ann_color list using rep information
  ann_color = list(rep = c("rep1" = "darkslategray2", "rep2" = "yellow2", "rep3" = "thistle1" ), condition = c("control" = "mediumseagreen", "drought" = "hotpink")) #  "seagreen2", "hotpinkdarkseagreen1"
  
  # Add Condition info to ann_color
  # ann_color[[Condition]] = c("turquoise4", "olivedrab")
  
  # Name the elements of Condition
  # names(ann_color[[Condition]]) = c(nominator, denominator)
  file_all =paste0(OutPath_plots, "10_clusters_heatmap_vst_countall_sigGenes.png")
  mat_all = mat[row.names(mat)  %in% nGene, ] 
  mat_top = mat[row.names(mat)  %in% nGene[1:topGene], ]
  # Color palettes: RGn, PiYG, BrBG, Spectral, RdBu, PuOr, RdYlBu, BrBG, Paired
  colorss = colorRampPalette(rev(brewer.pal(n = 4, name = "PuOr")))(10)
  title_all = paste0("Heatmap: VST counts of all ", length(nGene), "\n", "significantly differentially expressed ", Feature, "s", sep = " ")
  pheatmap::pheatmap(mat_all, color = colorss, cluster_cols = T, cluster_rows = T, show_colnames = T, show_rownames = F,  annotation_colors = ann_color, annotation_col =  ann_col, clustering_method = "ward.D", clustering_distance_rows = "euclidean", clustering_distance_cols =  "euclidean", fontsize_col = 4, angle_col = 90, cellheight = 0.8, cellwidth = 8, cutree_cols = 2, annotation_legend = T,legend = T, fontsize = 5, main = title_all, cutree_rows = 2, file = file_all)
  file_top = paste0(OutPath_plots, "11_clusters_heatmap_vst_count",topGene, "_top_sigGenes.png")
  title_top = paste0("Heatmap: VST counts of top ", topGene, "\n", "significantly differentially expressed ", Feature, "s", sep  = " ")
  pheatmap::pheatmap(mat_top, color = colorss, cluster_cols = T, cluster_rows = T, show_colnames = T, show_rownames = T,  annotation_colors = ann_color, annotation_col =  ann_col, clustering_method = "ward.D", clustering_distance_rows = "euclidean", clustering_distance_cols = "euclidean", fontsize_row = 8, fontsize_col = 7, angle_col = 90, cellheight = 12, cellwidth = 25, cutree_cols = 2, annotation_legend = T,legend = T, fontsize = 8, main =  title_top, cutree_rows = 3, file = file_top)
  
  # Both heatmaps illustrate the separation of samples based on the two conditions of interest.
  
  ### 9. DEGreport
  #### degPatterns plot
  # Using the degPatterns function from the *DEGreport* package we identified the sets of genes (clusters) that demonstrate similar expression patterns across different sample groups.</div>
  # Explore significant results: shrinked, Log2 FC >= 2, adjusted P-value <= 0.1
  # summary(res_shrink_F_tbl)
  # colnames(res_shrink_F_tbl)
  # str(res_shrink_F_tbl)
  print(resultsNames(ddsW))
  
  arrenged_sig_genes = res_shrink_F_tbl %>%
    dplyr::arrange(padj)
  vst_for_clustering = mat[arrenged_sig_genes$featureID, ]
  clusters = degPatterns(vst_for_clustering, metadata = meta, col = NULL , time = Condition , minc = 1, plot = F, groupDifference = 0.4, reduce = T) # reduce=T, scale=T, consensusCluster=
  png(paste0(OutPath_plots, "12_clusters_vst_lfc_", lfc, "_padj_", padj, ".png", sep = ""), width=5,height=3.5,units="in",res=600)
  print(degPlotCluster(clusters$normalized, color = Condition, time = Condition, prefix_title = "Cluster: ", points = T, min_genes = 1, lines = T, boxes = T, smooth = T, facet = T , process = FALSE, cluster_column = "cluster") )
  dev.off()
  
  # Make groups of genes using expression profile for DEGs with abs(log2 FC) >= 2 and adj P-value <= 0.5, remove genes that are outliers of the cluster distribution and minimum abundance difference 1 between the maximum value and minimum value for each feature in log2 range.
  # It can work with one or more groups with 2 or more several time points. Before calculating the genes similarity among samples, all samples inside the same time point (time parameter) and group (col parameter) are collapsed together, and the mean value is the representation of the group for the gene abundance. Then, all pair-wise gene expression is calculated using cor.test R function using kendall as the statistical method. A distance matrix is created from those values. After that, cluster::diana() is used for the clustering of gene-gene distance matrix and cut the tree using the divisive coefficient of the clustering, giving as well by diana. Alternatively, if consensusCluster is on, it would use ConsensusClusterPlus to cut the tree in stable clusters. Finally, for each group of genes, only the ones that have genes higher than minc parameter will be added to the figure. The y-axis in the figure is the results of applying scale() R function, what is similar to creating a Z-score where values are centered to the mean and scaled to the ⁠standard desviation⁠ by each gene.
  # The different patterns can be merged to get similar ones into only one pattern. The expression correlation of the patterns will be used to decide whether some need to be merged or not.
  # the degPatterns tool uses a hierarchical clustering approach based on pair-wise correlations, then cuts the hierarchical tree to generate groups of genes with similar expression profiles. The tool cuts the tree in a way to optimize the diversity of the clusters, such that the variability inter-cluster > the variability intra-cluster" 
  
  #### Cluster components
  df_geneCluster = clusters$df
  print("Number of detected expression pattern clusters" )
  print(paste0(" in ", nrow(res_shrink_F_tbl), " significantly differentially expressed ", Feature, "s using |Log2 FC| ≥ ", lfc , " and adjusted P-value ≤ ", padj, " is " , length(unique(df_geneCluster$cluster)), "."))
  
  df_geneCluster = df_geneCluster[order(df_geneCluster$cluster, decreasing = FALSE),]
  res_out = paste0(OutPath_tables, "12_clusters_transcripts_DESeq2_lfc_", lfc, "_padj_", padj, ".tsv",sep="")
  write.table(as.data.frame(df_geneCluster),file=res_out, quote = FALSE,row.names=FALSE,sep = "\t")
  
}  

### 10. References

# Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4302049/)
# Analyzing RNA-seq data with DESeq2](https://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)
# QC and downstream analysis for differential expression RNA-seq](https://www.bioconductor.org/packages/release/bioc/vignettes/DEGreport/inst/doc/DEGreport.html)
# Additionally, several free online resources were utilized in compiling this report.

sink("sessionInfo.txt")
sessionInfo()
sink()





